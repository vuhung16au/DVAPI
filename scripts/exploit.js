#!/usr/bin/env node

/**
 * Main exploit script for DVAPI
 * Registers a test user, logs in, and runs all exploit scripts
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

const BASE_URL = process.argv[2] || 'http://localhost:3000';
const SCRIPTS_DIR = __dirname;
const EXPLOITS_DIR = path.join(SCRIPTS_DIR, 'exploits');
const LOGS_DIR = path.join(SCRIPTS_DIR, '..', 'logs');

// Create logs directory
if (!fs.existsSync(LOGS_DIR)) {
    fs.mkdirSync(LOGS_DIR, { recursive: true });
}

// Generate random username and password
const TEST_USER = `testuser_${Date.now()}`;
const TEST_PASS = `testpass_${crypto.randomBytes(8).toString('hex')}`;
const LOG_FILE = path.join(LOGS_DIR, 'exploit.log');

// Logging utility
function log(message) {
    const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);
    const logMessage = `[${timestamp}] ${message}`;
    console.log(logMessage);
    fs.appendFileSync(LOG_FILE, logMessage + '\n');
}

// HTTP request utility using fetch (Node.js 18+)
async function httpRequest(url, options = {}) {
    try {
        const response = await fetch(url, {
            ...options,
            headers: {
                'Content-Type': 'application/json',
                ...options.headers,
            },
        });
        const text = await response.text();
        let data;
        try {
            data = JSON.parse(text);
        } catch {
            data = text;
        }
        return { status: response.status, data, text };
    } catch (error) {
        return { error: error.message };
    }
}

// Check if DVAPI is accessible
async function checkDVAPI() {
    log('Checking if DVAPI is accessible...');
    const result = await httpRequest(BASE_URL, { method: 'GET' });
    if (result.status && [200, 301, 302].includes(result.status)) {
        log('✅ DVAPI is accessible');
        return true;
    }
    log(`ERROR: DVAPI is not accessible at ${BASE_URL}`);
    log('Please ensure DVAPI is running (use \'make build-docker\')');
    return false;
}

// Register test user
async function registerUser() {
    log('Registering test user...');
    const result = await httpRequest(`${BASE_URL}/api/register`, {
        method: 'POST',
        body: JSON.stringify({
            username: TEST_USER,
            password: TEST_PASS,
        }),
    });

    if (result.data && (result.data.status === 'success' || result.data.message?.includes('success'))) {
        log('✅ User registered successfully');
        return true;
    } else {
        log(`⚠️  Registration response: ${JSON.stringify(result.data)}`);
        // Try to continue anyway in case user already exists
        return true;
    }
}

// Login and get JWT token
async function login() {
    log('Logging in to get JWT token...');
    const result = await httpRequest(`${BASE_URL}/api/login`, {
        method: 'POST',
        body: JSON.stringify({
            username: TEST_USER,
            password: TEST_PASS,
        }),
    });

    if (result.error) {
        log(`⚠️  Login error: ${result.error}`);
        return null;
    }

    // Try to extract token from response
    let token = null;
    if (result.data) {
        if (result.data.token) {
            token = result.data.token;
        } else if (result.data.message && result.data.message.includes('success')) {
            // Token might be in cookie or header, but for now we'll try without
            log('⚠️  Token not found in response, but login appears successful');
        }
    }

    if (token) {
        log('✅ JWT token obtained');
    } else {
        log('⚠️  Could not extract JWT token, some exploits may fail');
        log(`Login response: ${JSON.stringify(result.data)}`);
    }

    return token;
}

// Run exploit script
async function runExploit(scriptName, vulnName) {
    log(`Running ${scriptName} - ${vulnName}...`);
    const scriptPath = path.join(EXPLOITS_DIR, scriptName);
    
    if (!fs.existsSync(scriptPath)) {
        log(`❌ Script not found: ${scriptPath}`);
        return false;
    }

    try {
        // Import and run the exploit module
        delete require.cache[require.resolve(scriptPath)];
        const exploit = require(scriptPath);
        const result = await exploit.run(TOKEN, BASE_URL, TEST_USER, TEST_PASS);
        
        if (result && result.success) {
            log(`✅ ${scriptName} completed successfully`);
            return true;
        } else {
            log(`❌ ${scriptName} failed`);
            return false;
        }
    } catch (error) {
        log(`❌ ${scriptName} error: ${error.message}`);
        return false;
    }
}

// Main execution
async function main() {
    log('==========================================');
    log('DVAPI Automated Exploit Execution');
    log('==========================================');
    log(`Base URL: ${BASE_URL}`);
    log(`Test User: ${TEST_USER}`);
    log('');

    // Check if DVAPI is accessible
    if (!(await checkDVAPI())) {
        process.exit(1);
    }

    // Register test user
    await registerUser();

    // Login and get token
    const TOKEN = await login();
    global.TOKEN = TOKEN; // Make available to exploit scripts

    log('');
    log('Running exploit scripts...');
    log('');

    // Array of exploit scripts in order
    const EXPLOITS = [
        { script: '0xa1.js', name: 'Broken Object Level Authorization' },
        { script: '0xa2.js', name: 'Broken Authentication' },
        { script: '0xa3.js', name: 'Broken Object Property Level Authorization' },
        { script: '0xa4.js', name: 'Unrestricted Resource Consumption' },
        { script: '0xa5.js', name: 'Broken Function Level Authorization' },
        { script: '0xa6.js', name: 'Unrestricted Access to Sensitive Business Flows' },
        { script: '0xa7.js', name: 'Server-Side Request Forgery' },
        { script: '0xa8.js', name: 'Security Misconfiguration' },
        { script: '0xa9.js', name: 'Improper Inventory Management' },
        { script: '0xaa.js', name: 'Unsafe Consumption of APIs' },
    ];

    let successCount = 0;
    let failCount = 0;

    for (const exploit of EXPLOITS) {
        const success = await runExploit(exploit.script, exploit.name);
        if (success) {
            successCount++;
        } else {
            failCount++;
        }
        log('');
    }

    log('==========================================');
    log('Exploit Execution Summary');
    log('==========================================');
    log(`Total exploits: ${EXPLOITS.length}`);
    log(`Successful: ${successCount}`);
    log(`Failed: ${failCount}`);
    log('==========================================');
    log('');
    log(`Detailed logs saved to: ${LOG_FILE}`);
    log(`Individual exploit logs in: ${LOGS_DIR}/`);

    process.exit(0);
}

// Run main function
main().catch(error => {
    console.error('Fatal error:', error);
    process.exit(1);
});
